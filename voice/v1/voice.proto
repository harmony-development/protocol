syntax = "proto3";

import "harmonytypes/v1/types.proto";

package protocol.voice.v1;

option go_package = "github.com/harmony-development/legato/gen/voice/v1";

// Object representing a media kind.
enum MediaKind {
  // Kind representing audio media.
  MEDIA_KIND_AUDIO_UNSPECIFIED = 0;
  // Kind representing video media.
  MEDIA_KIND_VIDEO = 1;
}

// Object containing all the necessary information about transport options required
// from the server to establish transport connection on the client
message TransportOptions {
  // The transport ID.
  string id = 1;
  // DTLS paramaters in JSON.
  string dtls_paramaters = 2;
  // ICE candidates in JSON.
  string ice_candidates = 3;
  // ICE paramaters in JSON.
  string ice_paramaters = 4;
}

// Used in `StreamMessage` endpoint.
message StreamMessageRequest {
  message PrepareForJoinChannel {
    // RTP capabilities in JSON.
    string rtp_capabilities = 1;
  }

  // Join a channel after connecting transports
  //
  // This takes one RTP paramaters for one track, which will be
  // assumed to be Audio
  //
  // It also takes DTLS paramaters for connecting both producer and consumer
  message JoinChannel {
    // RTP paramaters in JSON.
    string rtp_paramaters = 1;
    string producer_dtls_paramaters = 2;
    string consumer_dtls_paramaters = 3;
  }

  // Message to resume a consumer
  message ConsumerResume {
    // ID of the consumer to resume.
    string consumer_id = 1;
  }

  // Guild ID of the guild where the channel is.
  uint64 guild_id = 1;
  // Channel ID of the voice channel to send this request to.
  uint64 channel_id = 2;

  // Message for this response
  oneof message {
    PrepareForJoinChannel prepare_for_join_channel = 3;
    JoinChannel join_channel = 4;
    // Sent to resume a consumer
    ConsumerResume consumer_resume = 5;
  }
}
// Used in `StreamMessage` endpoint.
message StreamMessageResponse {
  // Sent when client first connects the socket, clients have to wait for this message
  message Initialize {
    // Finalized router (aka server) RTP capabilities in JSON.
    string finalized_rtp_capabilities = 1;
  }

  message PreparedForJoinChannel {
    // Consumer transport options
    TransportOptions consumer_transport_options = 1;
    // Producer transport options
    TransportOptions producer_transport_options = 2;
  }

  // Producer for voice created; consumer and producer transports are connected
  message JoinedChannel {
    string producer_id = 1;
  }

  // Data for the user that joined the room and it's producer
  message UserJoined {
    uint64 user_id = 1;
    string producer_id = 2;
    string consumer_id = 3;
    string rtp_paramaters = 4;
  }

  // Data for the user that left the room and the producer
  message UserLeft {
    uint64 user_id = 1;
    string producer_id = 2;
  }
  
  // Guild ID of the guild where the channel is.
  uint64 guild_id = 1;
  // Channel ID of the voice channel this response is for.
  uint64 channel_id = 2;

  // Message for this response
  oneof message {
    PreparedForJoinChannel prepared_for_join_channel = 3;
    JoinedChannel joined_channel = 4;
    // Sent when a user joins the channel
    UserJoined user_joined = 5;
    // Sent when a user leaves the channel
    UserLeft user_left = 6;
  }
}

// Harmony service for facilitating voice operations using WebRTC.
//
// # Usage (for client)
// 1. Call StreamMessage to be able to send RTC commands to server
// 2. Init device by using the rtp capabilities sent in the first message
// 3. Send PrepareForJoinChannel over stream with client rtp capabilities
// 4. Wait for PreparedForJoinChannel, which contains transport options
// 5. Connect both transports using the transport options on client
// 6. Send JoinChannel over stream containing RTP paramaters for your Audio track
// and DTLS paramaters for both consumer and producer
// 7. Wait for JoinedChannel, which confirms you have successfully joined the voice channel
// 8. Handle UserJoined and UserLeft events appropiately
//   - For UserJoined, use the received consumer ID, producer ID and RTP parameters on your
//     consumer transport to consume the producer, afterwards send ConsumerResume message
//     with the consumer ID, then add the track to wherever you store data for users
//   - For UserLeft, just remove the user by producer ID from wherever you store data for users
service VoiceService {
  // Endpoint to stream messages between client and server.
  rpc StreamMessage(stream StreamMessageRequest) returns (stream StreamMessageResponse) {
    option (harmonytypes.v1.metadata).requires_authentication = true;
  }
}
