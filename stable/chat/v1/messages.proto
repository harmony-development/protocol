syntax = "proto3";

package protocol.chat.v1;

import "harmonytypes/v1/types.proto";
import "emote/v1/types.proto";

// Overrides provide a way to override the name and avatar of a message.
message Overrides {
  // The overridden username.
  optional string username = 1;
  // The overridden avatar.
  //
  // This can be a file ID or an external image URL.
  optional string avatar = 2;
  // The reason for overriding username and avatar.
  oneof reason {
    // A custom reason in case the builtin ones don't fit.
    string user_defined = 3;
    // The override occured because of a webhook.
    harmonytypes.v1.Empty webhook = 4;
    // Plurality, not system as in computer.
    harmonytypes.v1.Empty system_plurality = 5;
    // The override occured because it was made by the server.
    //
    // Servers should reject messages sent by users with this override.
    harmonytypes.v1.Empty system_message = 6;
    // The override occured because of bridging.
    harmonytypes.v1.Empty bridge = 7;
  }
}

// The payload sent to the bot when an action is triggered.
message ActionPayload {
  // The payload data for a button action.
  message Button {
    // The data from the Button action.
    bytes data = 1;
  }
  // The payload for a dropdown action.
  message Dropdown {
    // The user choice from the dropdown.
    bytes choice = 1;
  }
  // The payload for a text input action.
  message Input {
    // The user input.
    string input = 1;
    // The bot-provided data.
    bytes data = 2;
  }
  // The payload data.
  oneof payload {
    // Payload for a button.
    Button button = 1;
    // Payload for a dropdown.
    Dropdown dropdown = 2;
    // Payload for a text input.
    Input input = 3;
  }
}

// Actions are interactive elements that can exist within an embed.
message Action {
  // The action type. This is primarily used to change the look of the action to
  // the user (example: Destructive actions will have a red background).
  enum Type {
    // A normal action.
    TYPE_NORMAL_UNSPECIFIED = 0;
    // A primary action.
    TYPE_PRIMARY = 1;
    // A destructive / dangerous action.
    TYPE_DESTRUCTIVE = 2;
  }

  // A button that users can click on to trigger an action.
  message Button {
    // The text to show on the button.
    string text = 1;

    // Action data, which should be used in the call to perform the action.
    bytes data = 2;

    // An external URL that the button links to.
    //
    // This makes it so that tapping this button will open said URL instead
    // of triggering the action.
    optional string url = 3;
  }

  // A dropdown menu that users can click on to trigger an action.
  message Dropdown {
    // The text describing the dropdown.
    string label = 1;

    // An entry in the dropdown.
    message Entry {
      // The dropdown's UI label.
      string label = 1;

      // The dropdown's associated data.
      bytes data = 2;
    }

    // The options in the dropdown.
    repeated Entry entries = 2;
  }
  // A text input that users can type in to trigger an action.
  message Input {
    // The label describing the input.
    string label = 1;
    // Whether this text input should be a multiline one or not.
    bool multiline = 2;
    // Contextual data allowing the bot to discern what the user input is for.
    bytes data = 3;
  }

  // Type of the action.
  Type action_type = 1;

  // The kind of the action.
  oneof kind {
    // Button action.
    Button button = 2;
    // Dropdown action.
    Dropdown dropdown = 3;
    // Input action.
    Input input = 4;
  }
}

// Object representing a message embed.
message Embed {
  // Object representing an embed heading.
  message Heading {
    // Text of the heading.
    string text = 1;
    // URL of the heading.
    //
    // If this is provided, clients should make it so that
    // interacting with the heading opens this URL, for example
    // clicking on it.
    optional string url = 2;
    // Icon of the heading. This must be a file ID that points
    // to an image.
    optional string icon = 3;
  }

  // A field for the embed. Fields usually contain
  // small information and are not meant to be used
  // for huge chunks of text.
  message Field {
    // Title of this field (what is it?).
    string title = 1;
    // Body of this field.
    string body = 2;
  }

  // Data for displaying an image in embed.
  //
  // Servers should fill in the `width` and `height` fields, if
  // the provided `id` is not external.
  message Image {
    // File ID or external image URL of an image.
    string id = 1;
    // The width of the image, in pixels.
    uint32 width = 2;
    // The height of the image, in pixels.
    uint32 height = 3;
  }

  // Embed heading for the header.
  optional Heading header = 1;
  // Title of this embed.
  string title = 2;
  // Body text of this embed.
  optional FormattedText body = 3;
  // Fields of this embed.
  repeated Field fields = 4;
  // An image to display on this embed.
  optional Image image = 5;
  // Actions to show on this field.
  repeated Action actions = 6;
  // Embed heading for the footer.
  optional Heading footer = 7;
  // Color of this embed.
  optional int32 color = 8;
}


// An extremely low-quality WebP thumbnail.
//
// The resolution is usually no larger than 64x64.
message Minithumbnail {
  // The width of the minithumbnail, in pixels.
  uint32 width = 1;
  // The height of the minithumbnail, in pixels.
  uint32 height = 2;
  // The data of the minithumbnail.
  bytes data = 3;
}

// Object representing a generic message attachment.
message Attachment {
  // Contains data about an image.
  message ImageInfo {
    // The width of the image, in pixels.
    uint32 width = 1;
    // The height of the image, in pixels.
    uint32 height = 2;
    // A thumbnail for the image.
    Minithumbnail minithumbnail = 3;
    // The image's caption.
    optional string caption = 4;
  }

  // File ID of this attachment.
  string id = 1;
  // Filename of this attachment.
  string name = 2;
  // Mimetype of this attachment.
  string mimetype = 3;
  // File size of this attachment, in bytes.
  uint32 size = 4;
  // Extra info.
  oneof info {
    // Image info.
    ImageInfo image = 5;
  }
}

// Object representing a message's content other than text.
//
// `InviteRejected`, `InviteAccepted` and `RoomUpgradedToGuild`, can only
// be used by servers themselves. Servers should reject messages with this
// content if they are sent by a user.
//
// Text should be displayed before embeds, and embeds should be displayed before attachments.
message Content {
  // Represents a user rejecting an invite.
  message InviteRejected {
    // User ID of the invitee.
    uint64 invitee_id = 1;
    // User ID of the inviter.
    uint64 inviter_id = 2;
  }
  // Represents a user accepting an invite.
  message InviteAccepted {
    // User ID of the invitee.
    uint64 invitee_id = 1;
    // User ID of the inviter.
    uint64 inviter_id = 2;
  }
  // Represents a guild upgrade from "room" to "normal".
  message RoomUpgradedToGuild {
    // User ID of the user that upgraded the guild.
    uint64 upgraded_by = 1;
  }

  // Text content of the message.
  string text = 1;
  // Text formatting of the text content.
  repeated Format text_formats = 2;
  // Embed content.
  repeated Embed embeds = 3;
  // Attachment content.
  repeated Attachment attachments = 4;

  // Extra content data, in addition to the text content.
  oneof extra {
    // A user rejected an invite.
    InviteRejected invite_rejected = 5;
    // A user accepted an invite.
    InviteAccepted invite_accepted = 6;
    // A user upgraded a guild from "room" to "normal".
    RoomUpgradedToGuild room_upgraded_to_guild = 7;
  }
}

// Object representing a reaction.
message Reaction {
  // Emote data for this reaction.
  //
  // - Emote's image ID is used as an identifier for unique reactions.
  // - Emotes with the same names should be "deduplicated" by a client,
  // by suffixing their names with `~1`, `~2` and so on.
  emote.v1.Emote emote = 1;
  // How many times this reaction has been used.
  uint32 count = 2;
}

// A format for text.
message Format {
  // Bold text.
  message Bold {}
  // Italic text.
  message Italic {}
  // Underlined text.
  message Underline {}
  // Monospace text.
  message Monospace {}
  // Superscript text.
  message Superscript {}
  // Subscript text.
  message Subscript {}
  // A larger codeblock, with a programming language specified.
  //
  // Clients should ideally not bound the width of codeblock messages,
  // possibly scrolling the codeblock horizontally separately from the
  // rest of the message.
  message CodeBlock {
    // Programming language of the code block.
    string language = 1;
  }
  // Mention of a user (on the current homeserver).
  message UserMention {
    // User ID of the user being mentioned.
    uint64 user_id = 1;
  }
  // Mention of a role (on the current guild).
  message RoleMention {
    // The role being mentioned.
    uint64 role_id = 1;
  }
  // Mention of a channel (on the current guild).
  message ChannelMention {
    // The channel being mentioned.
    uint64 channel_id = 1;
  }
  // Mention of a guild.
  message GuildMention {
    // The guild being mentioned.
    uint64 guild_id = 1;
    // Which homeserver it belongs to.
    string homeserver = 2;
  }
  // An emoji.
  message Emoji {
    // The emote data of the emoji.
    emote.v1.Emote emote = 1;
  }
  // Colour modification.
  message Color {
    // The kind of colour modification to apply.
    enum Kind {
      // Dimmed colour.
      KIND_DIM_UNSPECIFIED = 0;
      // Brightened colour.
      KIND_BRIGHT = 1;
      // Negative colour (usually red).
      KIND_NEGATIVE = 2;
      // Positive colour (usually green).
      KIND_POSITIVE = 3;
      // Informational colour (usually blue).
      KIND_INFO = 4;
      // Warning colour (usually yellow-orange).
      KIND_WARNING = 5;
    }

    // The kind of colour modification to apply.
    Kind kind = 1;
  }
  // Replace a part of the text with the text matching the i18n code.
  // If i18n code was not found, keep the original text.
  message Localization {
    // i18n code for the text.
    string i18n_code = 1;
  }

  // Where the format begins to apply to.
  uint32 start = 1;
  // How many characters the format is.
  uint32 length = 2;

  // The style if format to apply to this text.
  oneof format {
    // A text format for bold text.
    Bold bold = 3;
    // A text format for italic text.
    Italic italic = 4;
    // A text format for underline text.
    Underline underline = 5;
    // A text format for monospace text.
    Monospace monospace = 6;
    // A text format for superscript text.
    Superscript superscript = 7;
    // A text format for subscript text.
    Subscript subscript = 8;
    // A text format for a codeblock.
    CodeBlock code_block = 9;
    // A text format for a user mention.
    UserMention user_mention = 10;
    // A text format for a role mention.
    RoleMention role_mention = 11;
    // A text format for a channel mention.
    ChannelMention channel_mention = 12;
    // A text format for a guild mention.
    GuildMention guild_mention = 13;
    // A text format for an emoji.
    Emoji emoji = 14;
    // A text format for coloured text.
    Color color = 15;
    // A text format for localization.
    Localization localization = 16;
  }
}

// Formatted text.
message FormattedText {
  // The textual content of a message.
  string text = 1;
  // The formats for a message.
  repeated Format format = 2;
}

// Object representing a message without the ID part.
message Message {
  // Metadata of this message.
  optional harmonytypes.v1.Metadata metadata = 1;
  // Overrides of this message.
  Overrides overrides = 2;
  // User ID of the user who sent this message.
  uint64 author_id = 3;
  // When this message was created, in seconds since unix epoch.
  uint64 created_at = 4;
  // The most recent time this message was edited, in seconds since unix epoch.
  optional uint64 edited_at = 5;
  // The message this message is a reply to.
  optional uint64 in_reply_to = 6;
  // The content of the message.
  Content content = 7;
  // The reactions of the message.
  repeated Reaction reactions = 8;
}

// Object representing a message with it's ID.
message MessageWithId {
  // ID of the message.
  uint64 message_id = 1;
  // The message data.
  Message message = 2;
}

// Used in the `GetChannelMessages` endpoint.
message GetChannelMessagesRequest {
  // The direction relative to the `message_id` message to get messages from.
  enum Direction {
    // Get messages before the anchor.
    DIRECTION_BEFORE_UNSPECIFIED = 0;
    // Get messages around the anchor, including the anchor.
    DIRECTION_AROUND = 1;
    // Get messages after the anchor.
    DIRECTION_AFTER = 2;
  }

  // Guild ID of the guild that has the channel.
  uint64 guild_id = 1;
  // Channel ID of the channel to get messages from.
  uint64 channel_id = 2;
  // The ID of the message that will be used as an "anchor" point to figure out
  // where to get the messages.
  // If not specified, the `direction` will be ignored and the newest messages
  // will be returned.
  optional uint64 message_id = 3;
  // On which direction to get the messages.
  //
  // - By default, it is "before", which means you will get messages before the
  // `message_id` message.
  // - If it is "around", you will get the messages around the `message_id`
  // message. This will include the `message_id` message itself, as the middle
  // item of the list returned.
  // - If it is "after", you will get the messages after the `message_id`
  // message.
  optional Direction direction = 4;
  // How many messages to get.
  //
  // - If `0`, a recommended message count to return is 25. If the direction is
  // "around", the recommended value is 12.
  // - If the direction to get the messages is "around", this count will not be
  // the *total* count of messages to return, but instead the count of messages
  // to return *for each direction*, before and after.
  // - Servers should enforce their own maximum limit, and clamp this value to
  // the limit.
  optional uint32 count = 5;
}
// Used in the `GetChannelMessages` endpoint.
message GetChannelMessagesResponse {
  // Has reached the top (first message) of the message history.
  bool reached_top = 1;
  // Has reached the bottom (last message) of the message history.
  bool reached_bottom = 2;
  // The messages requested.
  repeated MessageWithId messages = 3;
}

// Used in the `GetMessage` endpoint.
message GetMessageRequest {
  // Guild ID of the guild where the channel is.
  uint64 guild_id = 1;
  // Channel ID of the channel where the message is.
  uint64 channel_id = 2;
  // Message ID of the message you want to get.
  uint64 message_id = 3;
}
// Used in the `GetMessage` endpoint.
message GetMessageResponse {
  // The message requested.
  Message message = 1;
}

// Used in the `DeleteMessage` endpoint.
message DeleteMessageRequest {
  // Guild ID of the guild where the channel is.
  uint64 guild_id = 1;
  // Channel ID of the channel where the message is.
  uint64 channel_id = 2;
  // Message ID of the message you want to delete.
  uint64 message_id = 3;
}
// Used in the `DeleteMessage` endpoint.
message DeleteMessageResponse {}

// Used in the `TriggerAction` endpoint.
message TriggerActionRequest {
  // Guild ID of the guild where the channel is.
  uint64 guild_id = 1;
  // Channel ID of the channel where the message is.
  uint64 channel_id = 2;
  // Message ID of the message you want to trigger an action in.
  uint64 message_id = 3;
  // Payload of action data.
  ActionPayload payload = 4;
}
// Used in the `TriggerAction` endpoint.
message TriggerActionResponse {}

// Used in the `SendMessage` endpoint.
message SendMessageRequest {
  // Attachment info that can be sent by a user.
  message Attachment {
    // Information a user can add to a image attachment.
    message ImageInfo {
      // The image's caption.
      optional string caption = 1;
      // Whether to use the original image, instead of compressing the image.
      //
      // Compression can be forced by servers, so this option may not work on
      // every homeserver.
      bool use_original = 2;
    }

    // The local file ID of the attachment.
    string id = 1;
    // Name of the attachment.
    string name = 2;
    // Extra information.
    oneof info {
      // Image info.
      ImageInfo image = 3;
    }
  }

  // Content that can be sent by a user.
  message Content {
    // Text content of the message to be sent.
    //
    // If this is empty, then either `attachments`
    // or `embeds` must be specified.
    string text = 1;
    // Text formats for the text content.
    repeated Format text_formats = 2;
    // Attachments to be sent.
    //
    // If this is empty, then either `embeds` or `text`
    // must be specified.
    repeated Attachment attachments = 3;
    // Embeds to be sent.
    //
    // If this is empty, then either `attachemnts`
    // or `text` must be specified.
    repeated Embed embeds = 4;
  }

  // Guild ID of the guild where the channel is.
  uint64 guild_id = 1;
  // Channel ID of the channel you want to send a message in.
  uint64 channel_id = 2;
  // Content of the new message.
  Content content = 3;
  // Echo ID of the new message. This can be used by clients to
  // determine whether a message has been broadcasted to other clients.
  // Note that this does not mean the broadcast reached other clients.
  optional uint64 echo_id = 4;
  // The overrides of this new message.
  optional Overrides overrides = 6;
  // The message this new message is a reply to.
  optional uint64 in_reply_to = 7;
  // The metadata of this new message.
  optional harmonytypes.v1.Metadata metadata = 5;
}
// Used in the `SendMessage` endpoint.
message SendMessageResponse {
  // Message ID of the message sent.
  uint64 message_id = 1;
}

// Used in the `UpdateMessageText` endpoint.
message UpdateMessageTextRequest {
  // Guild ID of the guild where the channel is.
  uint64 guild_id = 1;
  // Channel ID of the channel where the message is.
  uint64 channel_id = 2;
  // Message ID of the message you want to edit the text of.
  uint64 message_id = 3;
  // New content for this message.
  FormattedText new_content = 4;
}
// Used in the `UpdateMessageText` endpoint.
message UpdateMessageTextResponse {}

// Used in the `PinMessage` endpoint.
message PinMessageRequest {
  // Guild ID of the guild where the channel is.
  uint64 guild_id = 1;
  // Channel ID of the channel where the message is.
  uint64 channel_id = 2;
  // Message ID of the message we want to pin.
  uint64 message_id = 3;
}
// Used in the `UnpinMessage` endpoint.
message PinMessageResponse {}

// Used in the `UnpinMessage` endpoint.
message UnpinMessageRequest {
  // Guild ID of the guild where the channel is.
  uint64 guild_id = 1;
  // Channel ID of the channel where the message is.
  uint64 channel_id = 2;
  // Message ID of the message we want to unpin.
  uint64 message_id = 3;
}
// Used in the `UnpinMessage` endpoint.
message UnpinMessageResponse {}

// Used in the `GetPinnedMessages` endpoint.
message GetPinnedMessagesRequest {
  // Guild ID of the guild where the channel is.
  uint64 guild_id = 1;
  // Channel ID of the channel we want to get pins of.
  uint64 channel_id = 2;
}

// Used in the `GetPinnedMessages` endpoint.
message GetPinnedMessagesResponse {
  // The IDs of the pinned messages.
  repeated uint64 pinned_message_ids = 1;
}

// Used in `AddReaction` endpoint.
message AddReactionRequest {
  // Guild ID of the guild where the channel is.
  uint64 guild_id = 1;
  // Channel ID of the channel where the message is.
  uint64 channel_id = 2;
  // Message ID of the message we want to add a reaction to.
  uint64 message_id = 3;
  // The emote we want to react with.
  emote.v1.Emote emote = 4;
}
// Used in `AddReaction` endpoint.
message AddReactionResponse {}

// Used in `RemoveReaction` endpoint.
message RemoveReactionRequest {
  // Guild ID of the guild where the channel is.
  uint64 guild_id = 1;
  // Channel ID of the channel where the message is.
  uint64 channel_id = 2;
  // Message ID of the message we want to remove a reaction.
  uint64 message_id = 3;
  // The emote we want to remove the react of.
  emote.v1.Emote emote = 4;
}
// Used in `RemoveReaction` endpoint.
message RemoveReactionResponse {}
