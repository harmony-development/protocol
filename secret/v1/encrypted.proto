syntax = "proto3";

package protocol.secret.v1;
option go_package = "github.com/harmony-development/legato/gen/secret/v1";

import "google/protobuf/timestamp.proto";

import "secret/v1/messages.proto";
import "secret/v1/state.proto";
import "secret/v1/keys.proto";

message Fanout {
	// The fanout of keys to room members. Clients should ignore fannounts
	// that don't have a user ID for every trusted key.
	//
	// Key: user ID
	// Value: 256-bit AES key. This will be the same for every user ID, difference
	// being that it's signed with the public key of the addressed user.
	map<uint64,Key> keys = 1;
}

message Flow {
	oneof content {
		Message message = 2;
		State state_event = 3;
		google.protobuf.Empty new_key = 4;
	}

	google.protobuf.Timestamp sent_at = 1;
}

message SignedMessage {
	// The message, in bytes form, unencrypted. Always contains a serialised Flow.
	bytes message = 1;
	// The signature of the byte stream of 'message'. Messages with an invalid
	// or untrusted signature should be disregarded.
	bytes signature = 2;
	// Who the message purports to be from, for purposes of looking up a public key.
	// The public key should be located in the room's state of trusted keys.
	uint64 from_user = 3 [ jstype = JS_STRING ];
	// The fanout of this message, if it has one.
	Fanout fanout = 4;
}

// EncryptedMessage, signed using the channel's current public key
message EncryptedMessage {
	// Will only ever contain a SignedMessage.
	bytes message = 1;

	// A strictly increasing number uniquely identifiying an event
	uint64 id = 2 [ jstype = JS_STRING ];
}

message PostedMessage {
	SignedMessage message = 1;
	string stream_id = 2;
}
