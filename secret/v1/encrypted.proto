syntax = "proto3";

package protocol.secret.v1;
option go_package = "github.com/harmony-development/legato/gen/secret/v1";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

import "secret/v1/messages.proto";
import "secret/v1/state.proto";
import "secret/v1/keys.proto";

message Flow {
	oneof content {
		Message message = 2;
		State state_event = 3;
	}

	google.protobuf.Timestamp sent_at = 1;
}

message SignedMessage {
	// The message, in bytes form, unencrypted. Always contains a serialised Flow.
	bytes message = 1;
	// The signature of the byte stream of 'message'. Messages with an invalid
	// or untrusted signature should be disregarded.
	bytes signature = 2;
	// Who the message purports to be from, for purposes of looking up a public key.
	// The public key should be located in the room's state of trusted keys.
	uint64 from_user = 3 [ jstype = JS_STRING ];
}

// EncryptedMessage, signed using the channel's current public key
message EncryptedMessage {
	// Will only ever contain a SignedMessage.
	bytes message = 1;

	// A strictly increasing number uniquely identifiying an event. This is used
	// to indicate where the olm ratchet should be wound to.
	uint64 id = 2 [ jstype = JS_STRING ];
}

message PostedMessage {
	SignedMessage message = 1;
	string stream_id = 2;
}
