syntax = "proto3";

// empty
import "google/protobuf/empty.proto";

// harmony types
import "harmonytypes/v1/types.proto";

// other files
import "secret/v1/keys.proto";
import "secret/v1/encrypted.proto";
import "secret/v1/messages.proto";

// package info
package protocol.secret.v1;
option go_package = "github.com/harmony-development/legato/gen/secret/v1";

message ChannelPair {
	string message_id = 1;
	string state_id = 2;
}

message ManageStream {
	repeated string subscribe_to = 1;
	repeated string unsubscribe_to = 2;
}

message PostMessageResponse {
	uint64 event_id = 1 [ jstype = JS_STRING ];
}

service SecretService {
	// The key should be a Ed25519 public key
	rpc PostKey(Key) returns(google.protobuf.Empty) {
		option (harmonytypes.v1.metadata).requires_authentication = true;
	}
	rpc FetchKey(FetchKeyRequest) returns(FetchKeyResponse) {
		option (harmonytypes.v1.metadata).requires_authentication = true;
	}

	// The key should be the Ed25519 private key for the
	// public key posted to PostKey; encrypted using 256-bit AES
	// with the key generated from SHA3-256 on a user-provided password.
	rpc PostPrivateKey(Key) returns(google.protobuf.Empty) {
		option (harmonytypes.v1.metadata).requires_authentication = true;
	}
	rpc FetchPrivateKey(google.protobuf.Empty) returns(Key) {
		option (harmonytypes.v1.metadata).requires_authentication = true;
	}

	// Create a channel pair
	rpc GenerateChannelPair(google.protobuf.Empty) returns(ChannelPair) {
		option (harmonytypes.v1.metadata).requires_authentication = true;
	}

	// Post an encrypted message to a channel
	rpc PostMessage(PostedMessage) returns(PostMessageResponse) {
		option (harmonytypes.v1.metadata).requires_authentication = true;
	}

	// Stream encrypted
	rpc StreamMessagePosting(stream ManageStream) returns(stream PostedMessage) {
		option (harmonytypes.v1.metadata).requires_authentication = true;
	}
}
