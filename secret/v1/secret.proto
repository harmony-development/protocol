syntax = "proto3";

import "google/protobuf/empty.proto";

import "harmonytypes/v1/types.proto";

package protocol.secret.v1;

option go_package = "github.com/harmony-development/legato/gen/secret/v1";

// Any key data; public or private
message Key {
	bytes key_data = 1;
}
message FetchKeyRequest {
	uint64 user_id = 1 [ jstype = JS_STRING ];
	string homeserver = 2;
}
message FetchKeyResponse {
	Key current_key = 1;
	repeated Key past_keys = 2;
}

message ChannelPair {
	string message_id = 1;
	string state_id = 2;
}

message EncryptedMessage {
	bytes message = 1;
}
message PostedMessage {
	EncryptedMessage message = 1;
	string stream_id = 2;
}

service SecretService {
	// The key should be a 4096-bit RSA public key
	rpc PostKey(Key) returns(google.protobuf.Empty) {
		option (harmonytypes.v1.metadata).requires_authentication = true;
	}
	rpc FetchKey(FetchKeyRequest) returns(FetchKeyResponse) {
		option (harmonytypes.v1.metadata).requires_authentication = true;
	}

	// The key should be the 4096-bit RSA private key for the
	// public key posted to PostKey; encrypted using ??????
	// TODO: figure out how clients should encrypt private key using a passphrase
	rpc PostPrivateKey(Key) returns(google.protobuf.Empty) {
		option (harmonytypes.v1.metadata).requires_authentication = true;
	}
	rpc FetchPrivateKey(Key) returns(google.protobuf.Empty) {
		option (harmonytypes.v1.metadata).requires_authentication = true;
	}

	// Create a channel pair
	rpc GenerateChannelPair(google.protobuf.Empty) returns(ChannelPair) {
		option (harmonytypes.v1.metadata).requires_authentication = true;
	}

	// Post an encrypted message to a channel
	rpc PostMessage(PostedMessage) returns(google.protobuf.Empty) {
		option (harmonytypes.v1.metadata).requires_authentication = true;
	}

	// Stream encrypted
	rpc StreamMessagePosting(stream PostedMessage) returns(stream PostedMessage) {
		option (harmonytypes.v1.metadata).requires_authentication = true;
	}
}
